[{"content":"Hey everyone, welcome to the first post here.\nOne of the projects I\u0026rsquo;ve been working on recently is what I called \u0026ldquo;GoCAN\u0026quot;. It\u0026rsquo;s an implementation of a Content Addressable Network, described here, which I\u0026rsquo;ve been working on with a friend of mine.\nWhat is a CAN? A Content Addressable Network is a network of systems which store a set of content-addressable data. What that means is the data in the network is stored in a distributed hash table, and the data is partitioned between different systems in the network. This distrubuted hash table is built to be scalable, allowing many different members to join the network and host data.\nManaging Data Data in a CAN is hashed to an n-dimensional Cartesian coordinate space, normalized in the range [0, 1) in any dimension. Our rudimentary implementation involves key-value pairs mapping strings to strings. The key string is hashed to an n-dimensional point, so that if someone were to search in the CAN using that key, they would retrieve the value string from the original insert.\nAny operations done to data, whether insert, updating, or deleting, require a key string.\nRouting and CAN Hosts When a CAN is initialized, the host creating the CAN owns the entire coordinate space in which data is stored. Once a separate process (on the same system or otherwise) decides to join the CAN, then it provides a key string which is hashed to a point in the coordinate space. The original CAN host will split the coordinate space and hand over half the region to the joining host, as well as any data that was hashed to that region.\nBecause a CAN is a distributed network, there must be some sort of routing data and requests throughout. If each CAN host were omniscient, then each one would have knowledge of all other hosts in the network. While this is a practical solution for a small network, if this were scaled up to hundreds of systems, then ensuring new systems are acknowledged by all existing hosts would be a difficult task.\nTo address this, each host only knows the information (IP address, listening port, and Cartesian space) about its immediate neighbors. This makes the joining process easier as only neighbors of the splitting CAN host must be updated.\nIf a client requests data from a CAN host that does not own the requested data, then it attempts to route the request to a neighbor whose regional midpoint is closed to point generated from the hashed key of the requested data.\nOur Implementation Our implementation of a CAN is done using Golang, or Go for short. Go is a feature-rich language which makes it easy to create a REST API using some community-written libraries. This was a good excuse for us to explore a new language and see its strengths and weaknesses.\nI had previously implemented a CAN for a project in a network theory class, using C/C++ and defining my own packet types to write over sockets. For this implementation, we decided it would be easier to use HTTP over TCP/IP, since we could leverage existing libraries without worrying about learning how to write over sockets in Go.\n","permalink":"https://portobello-boy.github.io/post/project-gocan/","summary":"Hey everyone, welcome to the first post here.\nOne of the projects I\u0026rsquo;ve been working on recently is what I called \u0026ldquo;GoCAN\u0026quot;. It\u0026rsquo;s an implementation of a Content Addressable Network, described here, which I\u0026rsquo;ve been working on with a friend of mine.\nWhat is a CAN? A Content Addressable Network is a network of systems which store a set of content-addressable data. What that means is the data in the network is stored in a distributed hash table, and the data is partitioned between different systems in the network.","title":"Project - GoCAN"},{"content":"Hey there.\nMy name is Daniel Millson, thanks for coming by to my blog. This is just a place for me to jot down my thoughts about stuff I\u0026rsquo;m working on or learning about, and I hope you\u0026rsquo;ll find some of the content interesting or inspiring in some way.\nHere\u0026rsquo;s a little bit about me. Growing up, I was fortunate to be able to travel, spending most of my pre-university years in South America and various countries in southern Africa, such as South Africa, Mozambique, and Zimbabwe.\nI had no idea I would end up studying Mathematics and Computer Science until I started at my university, where I ended up enjoying those subjects more than I would have imagined. While may day-to-day job is as a software developer in the financial service industry, I have a passion for learning different subjects in Math (though I\u0026rsquo;m by no means a mathematician).\nOther than writing software and learning Math, my hobbies include reading, cooking, and GeoCaching. I may post some content here regarding those, so keep your eyes out for those!\nAgain, thanks for coming by, and I hope you have a great day.\n","permalink":"https://portobello-boy.github.io/about/","summary":"Hey there.\nMy name is Daniel Millson, thanks for coming by to my blog. This is just a place for me to jot down my thoughts about stuff I\u0026rsquo;m working on or learning about, and I hope you\u0026rsquo;ll find some of the content interesting or inspiring in some way.\nHere\u0026rsquo;s a little bit about me. Growing up, I was fortunate to be able to travel, spending most of my pre-university years in South America and various countries in southern Africa, such as South Africa, Mozambique, and Zimbabwe.","title":"About Me"},{"content":"","permalink":"https://portobello-boy.github.io/archive/","summary":"archive","title":"Archive"},{"content":"","permalink":"https://portobello-boy.github.io/search/","summary":"search","title":"Search"}]